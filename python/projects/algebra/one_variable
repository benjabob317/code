#!/usr/bin/env python3

#expression = [[1, 2], [-4, 1], [0, 0]] #1x^2 - 4x^1 + 0x^0     x^2 - 4x
#another_expression = [[3, 1], [1, 0]] #3x^1 + 1x^0     3x + 1

def standard_form(expr): #puts expression in standard form
    expr.sort(key=lambda x: -x[1]) #orders by degree
    
    new_expr = []
    for x in expr: #removes terms equivalent to 0
        if x[0] != 0:
            new_expr.append(x)
    new_expr.sort(key=lambda x: -x[1]) #sorts terms by degree


    duplicate_degrees = [] #detects like terms
    for x in range(0, len(new_expr)):
        matches = [x]
        for y in range(0, x):
            if new_expr[x][1] == new_expr[y][1]:
                matches.append(y)
        if x != len(new_expr):
            for y in range(x+1, len(new_expr)):
                if new_expr[x] == new_expr[y]:
                    matches.append(y) #list of like terms
        matches.sort()
        if matches not in duplicate_degrees:
            if len(matches) > 1:
                duplicate_degrees.append(matches) #if there is more than one like term of a degree, adds list of like terms without repeats
    
    if len(duplicate_degrees) > 0: #if there are like terms that need to be combined
        non_duplicate_terms = [] #removes duplicate degree groups that are inside other duplicate degree pairs
        for x in range(0, len(duplicate_degrees)):
            valid = True
            for y in duplicate_degrees[0:x] + duplicate_degrees[x+1:len(duplicate_degrees)]:
                if all(elem in y for elem in duplicate_degrees[x]): #if x is in y
                    valid = False
            if valid == True:
                non_duplicate_terms.append(duplicate_degrees[x])
                
        combined_term_expr = []
        for x in non_duplicate_terms:
            new_coeff = 0
            for y in x:
                new_coeff += expr[y][0] #adds coefficients together
            expr[x[0]][0] = new_coeff #sets the first like term to the sum of all the like terms
            combined_term_expr.append(expr[x[0]]) #preserved only the sum of the like terms
        
        final_expr = []
        for x in combined_term_expr: #removes terms equivalent to 0
            if x[0] != 0:
                final_expr.append(x)
        final_expr.sort(key=lambda x: -x[1]) #sorts terms by degree
        return final_expr
    else:
        return new_expr


def interpret_expression(expr): #turns expression into readable form
    expr = standard_form(expr)

    output = ''
    for x in range(0, len(expr)):
        if x > 0: #if not the first term
            if expr[x][0] < 0: #if negative term, deals with minus signs
                if expr[x][0] == -1: #if coefficient is negative 1, removes coefficients of 1
                    output += '- '
                else:
                    output += '- ' + str(abs(expr[x][0]))
            else: #if positive
                if expr[x][0] != 1: #if coefficient not 1
                    output += str(expr[x][0])
                else:
                    if expr[x][1] == 0: #if term is equal to 1
                        output += '1'
        else: #if the first term
            if abs(expr[x][0]) != 1: #if positive 1 or negative 1, removes coefficient of 1
                output += str(expr[x][0])
            elif expr[x][0] == -1:
                output += '-'

        if expr[x][1] > 1:
            output += 'x^' + str(expr[x][1]) + ' ' #ex x^2
        elif expr[x][1] == 1:
            output += 'x '
        elif expr[x][1] == 0:
            output += ' '
        elif expr[x][1] == -1:
            output += '/x '
        else:
            output += '/x^' + str(expr[x][1]) + ' '
        if x != len(expr) - 1:
            if expr[x+1][0] > 0:
                output += '+ '
    return output

def equation_add(expr1, expr2, term): #adds a term to both sides of an equation, term example would be [5, 0] (adding the number 5)
    return standard_form(expr1 + [term]), standard_form(expr2 + [term])
#expr1, expr2 = equation_add(expr1, expr2, term)

expra, exprb = equation_add([[1, 1]], [[2, 1]], [1, 1])
print(expra)
print(exprb)